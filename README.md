# Two-Chain Asset Bridge with Relayer and Cross-Chain Governance

This repository implements a local omnichain-style bridge simulation with:

- Chain A (Settlement): `VaultToken`, `BridgeLock`, `GovernanceEmergency`
- Chain B (Execution): `WrappedVaultToken`, `BridgeMint`, `GovernanceVoting`
- Off-chain relayer (`relayer/`) with JSON persistence, confirmation delay, and retry logic
- Docker Compose orchestration for `chain-a`, `chain-b`, and `relayer`

## Repository Layout

- `contracts/` bridge and governance smart contracts
- `scripts/` chain-specific deployment scripts
- `relayer/` Node.js relayer service + Dockerfile
- `test/` Hardhat contract/unit tests
- `tests/` integration/failure simulation scripts
- `docker-compose.yml` full orchestration for both chains + relayer
- `.env.example` environment template

## Core Components

### Chain A (Settlement)

- `VaultToken.sol`: standard ERC20 settlement asset
- `BridgeLock.sol`:
  - `lock(uint256 amount)` transfers token into custody and emits `Locked(user, amount, nonce)`
  - `unlock(address user, uint256 amount, uint256 nonce)` only relayer
  - replay protection for unlock nonces
  - pause support with role-based access
- `GovernanceEmergency.sol`:
  - relayer-authorized `pauseBridge()` emergency hook
  - calls `BridgeLock.pauseBridge()`

### Chain B (Execution)

- `WrappedVaultToken.sol`: ERC20 with bridge-restricted mint/burn
- `BridgeMint.sol`:
  - `mintWrapped(user, amount, nonce)` only relayer
  - replay protection for mint nonces
  - `burn(amount)` for users and emits `Burned(user, amount, nonce)`
- `GovernanceVoting.sol`:
  - token-weighted voting
  - emits `ProposalPassed(proposalId, data)` on successful finalization

### Relayer

`relayer/src/index.js` listens to both chains and relays:

- `Locked` (Chain A) -> `mintWrapped` (Chain B)
- `Burned` (Chain B) -> `unlock` (Chain A)
- `ProposalPassed` (Chain B) -> `pauseBridge` (Chain A)

Reliability features:

- confirmation delay (`CONFIRMATION_DEPTH`, default 3)
- persistent processed IDs (`DB_PATH`, JSON)
- crash-safe atomic writes
- transaction retry loop

## Environment

Copy `.env.example` to `.env` and fill contract addresses after deployment.

Required bridge variables include:

- `DEPLOYER_PRIVATE_KEY`
- `CHAIN_A_RPC_URL`
- `CHAIN_B_RPC_URL`
- `CONFIRMATION_DEPTH`
- `DB_PATH`
- `CHAIN_A_BRIDGE_LOCK`
- `CHAIN_A_GOVERNANCE_EMERGENCY`
- `CHAIN_B_BRIDGE_MINT`
- `CHAIN_B_GOVERNANCE_VOTING`

Frontend variables include:

- `NEXT_PUBLIC_RPC_URL`
- `NEXT_PUBLIC_GOVERNOR_ADDRESS`
- `NEXT_PUBLIC_TOKEN_ADDRESS`
- `NEXT_PUBLIC_BOX_ADDRESS`

When running with Docker Compose, contract addresses are auto-generated by the `deployer` service and read by the relayer from `deployments/chain-a.json` and `deployments/chain-b.json`.

## Local Run (without Docker)

1) Install dependencies:

```bash
npm install
cd relayer && npm install
cd ..
```

1) Start both chains in separate terminals:

```bash
npm run node:chain-a
npm run node:chain-b
```

1) Deploy contracts:

```bash
npm run deploy:chain-a
npm run deploy:chain-b
```

Deployment outputs:

- `deployments/chain-a.json`
- `deployments/chain-b.json`

1) Fill `.env` contract address variables from deployment output.

2) Start relayer:

```bash
npm run relayer:start
```

## Docker Run

```bash
docker compose up --build
```

Services:

- `chain-a` on `8545` (chainId `1111`)
- `chain-b` on `9545` (chainId `2222`)
- `deployer` bootstraps both chains and writes deployment artifacts
- `relayer` with persistent state volume `./relayer_data`
- `frontend` on `3000`

## Testing

Contract/unit tests:

```bash
npm test
```

Bridge-focused tests:

```bash
npm run test:bridge
```

Integration/failure scripts:

```bash
npm run test:e2e-script
npm run test:recovery-script
```

## Submission Checklist Mapping

- Smart contracts: in `contracts/`
- Deployment scripts: `scripts/deploy-chain-a.js`, `scripts/deploy-chain-b.js`
- Relayer service: `relayer/` + `relayer/Dockerfile`
- Tests: `test/` and `tests/`
- Orchestration: root `docker-compose.yml`
- Env docs: root `.env.example`
- Documentation: this `README.md`

## Evaluator Quick Run

Use this sequence for a clean verification pass:

```bash
docker compose up -d --build
docker compose ps
npm test
```

Optional script validations (requires deployment-derived env vars):

```bash
npm run test:e2e-script
npm run test:recovery-script
npm run test:governance-script
```

## Core Requirements Traceability

1. **Containerization + health checks**: `docker-compose.yml` defines `chain-a`, `chain-b`, `deployer`, `relayer`, and `frontend`, each with health checks.
2. **Environment template**: root `.env.example` documents chain RPC, relayer, contract addresses, and frontend vars.
3. **ERC20Votes token**: `contracts/GovernanceToken.sol` extends OpenZeppelin ERC20Votes.
4. **Delegation support**: `GovernanceToken.delegate(address)` with `DelegateChanged` emission.
5. **Proposal threshold**: `contracts/MyGovernor.sol` enforces `proposalThreshold()` for proposal creation.
6. **Governor lifecycle**: proposal states are handled through OpenZeppelin Governor state machine (`Pending`, `Active`, `Succeeded`, `Defeated`, `Executed`).
7. **Voting window**: `votingDelay()` and `votingPeriod()` are configured and vote timing is enforced.
8. **Standard voting**: `MyGovernor.VotingType.Standard` maps 1 token to 1 vote.
9. **Quadratic voting**: `MyGovernor.VotingType.Quadratic` applies sqrt vote weight and quadratic token commitment.
10. **Snapshot voting power**: ERC20Votes snapshot via `getPastVotes` at proposal snapshot block.
11. **Quorum logic**: quorum enforced via Governor quorum module and tested in governance tests.
12. **Critical events**: includes `ProposalCreated`, `VoteCast`, and `ProposalExecuted` through Governor flow.
13. **Wallet connect test IDs**: frontend has `data-testid="connect-wallet-button"` and `data-testid="user-address"`.
14. **Proposal list test ID**: frontend renders proposals with `data-testid="proposal-list-item"` including title + status.
15. **Vote button test IDs**: active proposals expose `vote-for-button`, `vote-against-button`, `vote-abstain-button` and submit on-chain tx.

## Frontend Test IDs (for automation)

- `connect-wallet-button`
- `user-address`
- `proposal-list-item`
- `vote-for-button`
- `vote-against-button`
- `vote-abstain-button`

## Security Notes

- Replay protection on mint and unlock paths via nonce tracking
- Role-based access control for relayer-only actions
- Emergency pause path from cross-chain governance event
- Confirmation-depth waiting before relaying events
